{"version":3,"file":"apiTestingService.js","sources":["../src/aiSelfHealingService.ts","../src/selfHealing.ts","../src/apiTestingService.ts"],"sourcesContent":["/**\r\n * AI-Powered Self-Healing Service\r\n * Implements machine learning for intelligent locator healing\r\n */\r\n\r\nexport interface LocatorFeatures {\r\n  // Structural features\r\n  elementType: string;\r\n  hasId: boolean;\r\n  hasTestId: boolean;\r\n  hasAriaLabel: boolean;\r\n  hasRole: boolean;\r\n  hasName: boolean;\r\n  hasPlaceholder: boolean;\r\n  hasText: boolean;\r\n  hasClass: boolean;\r\n\r\n  // Content features\r\n  textLength: number;\r\n  textWordCount: number;\r\n  hasNumericText: boolean;\r\n  hasSpecialChars: boolean;\r\n\r\n  // Position features\r\n  depth: number;\r\n  siblingCount: number;\r\n  indexAmongSiblings: number;\r\n\r\n  // Style features\r\n  isVisible: boolean;\r\n  isClickable: boolean;\r\n  hasUniqueColor: boolean;\r\n  hasUniqueSize: boolean;\r\n\r\n  // Dynamic patterns\r\n  hasNumericId: boolean;\r\n  hasCssModuleClass: boolean;\r\n  hasTimestamp: boolean;\r\n  hasUuid: boolean;\r\n  hasRandomId: boolean;\r\n}\r\n\r\nexport interface MLModel {\r\n  predict(features: LocatorFeatures): number;\r\n  train(trainingData: { features: LocatorFeatures; label: number }[]): void;\r\n  save(): any;\r\n  load(data?: any): void;\r\n}\r\n\r\nexport interface VisualFingerprint {\r\n  // Visual properties\r\n  width: number;\r\n  height: number;\r\n  backgroundColor: string;\r\n  color: string;\r\n  fontSize: string;\r\n  fontFamily: string;\r\n  fontWeight: string;\r\n  border: string;\r\n  borderRadius: string;\r\n\r\n  // Position\r\n  x: number;\r\n  y: number;\r\n  zIndex: number;\r\n\r\n  // Content\r\n  text: string;\r\n  textHash: string;\r\n\r\n  // Computed hash\r\n  visualHash: string;\r\n}\r\n\r\nexport interface HealingHistory {\r\n  id: string;\r\n  originalLocator: string;\r\n  healedLocator: string;\r\n  success: boolean;\r\n  confidence: number;\r\n  timestamp: Date;\r\n  context: {\r\n    url: string;\r\n    elementType: string;\r\n    failureReason: string;\r\n  };\r\n  rollback?: {\r\n    timestamp: Date;\r\n    reason: string;\r\n  };\r\n}\r\n\r\nexport interface AutoHealingConfig {\r\n  enabled: boolean;\r\n  confidenceThreshold: number;\r\n  maxRetries: number;\r\n  rollbackAfterFailures: number;\r\n  requireUserApproval: boolean;\r\n  autoApproveHighConfidence: boolean;\r\n}\r\n\r\nexport class AISelfHealingService {\r\n  private mlModel: MLModel;\r\n  private healingHistory: Map<string, HealingHistory[]> = new Map();\r\n  private visualCache: Map<string, VisualFingerprint> = new Map();\r\n  private config: AutoHealingConfig = {\r\n    enabled: true,\r\n    confidenceThreshold: 0.85,\r\n    maxRetries: 3,\r\n    rollbackAfterFailures: 3,\r\n    requireUserApproval: false,\r\n    autoApproveHighConfidence: true\r\n  };\r\n\r\n  constructor() {\r\n    this.mlModel = new SimpleMLModel();\r\n    this.loadModel();\r\n    this.loadHistory();\r\n  }\r\n\r\n  /**\r\n   * Extract features from element for ML prediction\r\n   */\r\n  public extractFeatures(element: Element, locator: string): LocatorFeatures {\r\n    const computedStyle = window.getComputedStyle(element);\r\n    const rect = element.getBoundingClientRect();\r\n\r\n    // Structural features\r\n    const features: LocatorFeatures = {\r\n      elementType: element.tagName.toLowerCase(),\r\n      hasId: !!element.id,\r\n      hasTestId: !!element.getAttribute('data-testid'),\r\n      hasAriaLabel: !!element.getAttribute('aria-label'),\r\n      hasRole: !!element.getAttribute('role'),\r\n      hasName: !!element.getAttribute('name'),\r\n      hasPlaceholder: !!element.getAttribute('placeholder'),\r\n      hasText: !!(element.textContent?.trim()),\r\n      hasClass: !!element.className,\r\n\r\n      // Content features\r\n      textLength: element.textContent?.length || 0,\r\n      textWordCount: element.textContent?.trim().split(/\\s+/).length || 0,\r\n      hasNumericText: /\\d/.test(element.textContent || ''),\r\n      hasSpecialChars: /[!@#$%^&*(),.?\":{}|<>]/.test(element.textContent || ''),\r\n\r\n      // Position features\r\n      depth: this.getElementDepth(element),\r\n      siblingCount: element.parentElement?.children.length || 0,\r\n      indexAmongSiblings: Array.from(element.parentElement?.children || []).indexOf(element),\r\n\r\n      // Style features\r\n      isVisible: computedStyle.display !== 'none' && computedStyle.visibility !== 'hidden',\r\n      isClickable: ['button', 'a', 'input', 'select', 'textarea'].includes(element.tagName.toLowerCase()),\r\n      hasUniqueColor: this.isUniqueColor(computedStyle.color),\r\n      hasUniqueSize: this.isUniqueSize(rect.width, rect.height),\r\n\r\n      // Dynamic patterns\r\n      hasNumericId: /\\d{6,}/.test(element.id || ''),\r\n      hasCssModuleClass: /^css-\\w+/.test(element.className || ''),\r\n      hasTimestamp: /timestamp|time|date/i.test(element.id + element.className),\r\n      hasUuid: /[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/i.test(element.id || ''),\r\n      hasRandomId: /(random|rand|uuid|guid)/i.test(element.id + element.className)\r\n    };\r\n\r\n    return features;\r\n  }\r\n\r\n  /**\r\n   * Create visual fingerprint for element comparison\r\n   */\r\n  async createVisualFingerprint(element: Element): Promise<VisualFingerprint> {\r\n    const computedStyle = window.getComputedStyle(element);\r\n    const rect = element.getBoundingClientRect();\r\n\r\n    // Create a canvas for visual hash generation\r\n    const canvas = document.createElement('canvas');\r\n    const ctx = canvas.getContext('2d');\r\n    if (!ctx) throw new Error('Cannot create canvas context');\r\n\r\n    canvas.width = Math.min(rect.width, 100);\r\n    canvas.height = Math.min(rect.height, 100);\r\n\r\n    // Draw element representation\r\n    ctx.fillStyle = computedStyle.backgroundColor || '#ffffff';\r\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n    // Draw text if present\r\n    if (element.textContent) {\r\n      ctx.fillStyle = computedStyle.color || '#000000';\r\n      ctx.font = `${computedStyle.fontSize} ${computedStyle.fontFamily}`;\r\n      ctx.fillText(element.textContent.substring(0, 20), 5, 20);\r\n    }\r\n\r\n    // Generate hash from canvas\r\n    const visualHash = await this.canvasToHash(canvas);\r\n\r\n    const fingerprint: VisualFingerprint = {\r\n      width: rect.width,\r\n      height: rect.height,\r\n      backgroundColor: computedStyle.backgroundColor,\r\n      color: computedStyle.color,\r\n      fontSize: computedStyle.fontSize,\r\n      fontFamily: computedStyle.fontFamily,\r\n      fontWeight: computedStyle.fontWeight,\r\n      border: computedStyle.border,\r\n      borderRadius: computedStyle.borderRadius,\r\n      x: rect.left,\r\n      y: rect.top,\r\n      zIndex: parseInt(computedStyle.zIndex) || 0,\r\n      text: element.textContent?.substring(0, 100) || '',\r\n      textHash: this.hashString(element.textContent || ''),\r\n      visualHash\r\n    };\r\n\r\n    // Cache the fingerprint\r\n    const elementId = this.generateElementId(element);\r\n    this.visualCache.set(elementId, fingerprint);\r\n\r\n    return fingerprint;\r\n  }\r\n\r\n  /**\r\n   * Compare visual similarity between two elements\r\n   */\r\n  async compareVisualSimilarity(element1: Element, element2: Element): Promise<number> {\r\n    const fp1 = await this.createVisualFingerprint(element1);\r\n    const fp2 = await this.createVisualFingerprint(element2);\r\n\r\n    // Calculate similarity score (0-1)\r\n    let similarity = 0;\r\n    let factors = 0;\r\n\r\n    // Visual hash comparison (40% weight)\r\n    const hashSimilarity = this.compareHashes(fp1.visualHash, fp2.visualHash);\r\n    similarity += hashSimilarity * 0.4;\r\n    factors += 0.4;\r\n\r\n    // Size similarity (20% weight)\r\n    const sizeSimilarity = this.calculateSizeSimilarity(fp1, fp2);\r\n    similarity += sizeSimilarity * 0.2;\r\n    factors += 0.2;\r\n\r\n    // Style similarity (20% weight)\r\n    const styleSimilarity = this.calculateStyleSimilarity(fp1, fp2);\r\n    similarity += styleSimilarity * 0.2;\r\n    factors += 0.2;\r\n\r\n    // Position similarity (10% weight)\r\n    const positionSimilarity = this.calculatePositionSimilarity(fp1, fp2);\r\n    similarity += positionSimilarity * 0.1;\r\n    factors += 0.1;\r\n\r\n    // Text similarity (10% weight)\r\n    const textSimilarity = this.calculateTextSimilarity(fp1.text, fp2.text);\r\n    similarity += textSimilarity * 0.1;\r\n    factors += 0.1;\r\n\r\n    return factors > 0 ? similarity / factors : 0;\r\n  }\r\n\r\n  /**\r\n   * Predict locator success using ML model\r\n   */\r\n  async predictLocatorSuccess(element: Element, locator: string): Promise<{\r\n    confidence: number;\r\n    features: LocatorFeatures;\r\n    prediction: number;\r\n  }> {\r\n    const features = this.extractFeatures(element, locator);\r\n    const prediction = this.mlModel.predict(features);\r\n\r\n    return {\r\n      confidence: prediction,\r\n      features,\r\n      prediction\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Auto-heal failed locator with rollback capability\r\n   */\r\n  async autoHealLocator(\r\n    failedLocator: string,\r\n    element: Element,\r\n    context: { url: string; failureReason: string }\r\n  ): Promise<{\r\n    healedLocator: string;\r\n    confidence: number;\r\n    autoApplied: boolean;\r\n    requiresApproval: boolean;\r\n  }> {\r\n    // Check if auto-healing is enabled\r\n    if (!this.config.enabled) {\r\n      throw new Error('Auto-healing is disabled');\r\n    }\r\n\r\n    // Get healing history for this context\r\n    const historyKey = this.generateHistoryKey(failedLocator, context);\r\n    const history = this.healingHistory.get(historyKey) || [];\r\n\r\n    // Try alternative locators\r\n    const alternatives = await this.generateAlternativeLocators(element);\r\n\r\n    for (const alternative of alternatives) {\r\n      // Predict success using ML\r\n      const prediction = await this.predictLocatorSuccess(element, alternative.locator);\r\n\r\n      // Check if we have successful history with this alternative\r\n      const successfulHistory = history.filter(h =>\r\n        h.healedLocator === alternative.locator && h.success\r\n      );\r\n\r\n      // Boost confidence based on historical success\r\n      const historicalBoost = successfulHistory.length > 0 ? 0.1 : 0;\r\n      const finalConfidence = Math.min(1.0, prediction.confidence + historicalBoost);\r\n\r\n      // Determine if auto-apply\r\n      const autoApply = finalConfidence >= this.config.confidenceThreshold &&\r\n                       this.config.autoApproveHighConfidence;\r\n\r\n      if (finalConfidence >= this.config.confidenceThreshold) {\r\n        // Record healing attempt\r\n        const healingRecord: HealingHistory = {\r\n          id: this.generateId(),\r\n          originalLocator: failedLocator,\r\n          healedLocator: alternative.locator,\r\n          success: false, // Default to false, will be updated later\r\n          confidence: finalConfidence,\r\n          timestamp: new Date(),\r\n          context: {\r\n            ...context,\r\n            elementType: alternative.locator.split(/[#.\\[\\]]/)[0] || 'unknown'\r\n          }\r\n        };\r\n\r\n        history.push(healingRecord);\r\n        this.healingHistory.set(historyKey, history);\r\n        this.saveHistory();\r\n\r\n        return {\r\n          healedLocator: alternative.locator,\r\n          confidence: finalConfidence,\r\n          autoApplied: autoApply,\r\n          requiresApproval: !autoApply\r\n        };\r\n      }\r\n    }\r\n\r\n    throw new Error('No suitable alternative locator found');\r\n  }\r\n\r\n  /**\r\n   * Record healing result and handle rollback if needed\r\n   */\r\n  async recordHealingResult(\r\n    healingId: string,\r\n    success: boolean,\r\n    error?: string\r\n  ): Promise<void> {\r\n    // Find the healing record\r\n    let healingRecord: HealingHistory | undefined;\r\n    for (const history of this.healingHistory.values()) {\r\n      const record = history.find(h => h.id === healingId);\r\n      if (record) {\r\n        healingRecord = record;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (!healingRecord) {\r\n      throw new Error('Healing record not found');\r\n    }\r\n\r\n    // Update the record\r\n    healingRecord.success = success;\r\n\r\n    // If failed, check if rollback is needed\r\n    if (!success) {\r\n      const historyKey = this.generateHistoryKey(healingRecord.originalLocator, healingRecord.context);\r\n      const history = this.healingHistory.get(historyKey) || [];\r\n\r\n      // Count recent failures for this healed locator\r\n      const recentFailures = history\r\n        .filter(h => h.healedLocator === healingRecord.healedLocator)\r\n        .filter(h => {\r\n          const daysDiff = (Date.now() - h.timestamp.getTime()) / (1000 * 60 * 60 * 24);\r\n          return daysDiff <= 7; // Last 7 days\r\n        })\r\n        .filter(h => !h.success);\r\n\r\n      // Auto-rollback if too many failures\r\n      if (recentFailures.length >= this.config.rollbackAfterFailures) {\r\n        healingRecord.rollback = {\r\n          timestamp: new Date(),\r\n          reason: `Auto-rollback after ${recentFailures.length} failures`\r\n        };\r\n\r\n        // Mark this locator as unreliable\r\n        await this.markLocatorUnreliable(healingRecord.healedLocator);\r\n      }\r\n    }\r\n\r\n    this.saveHistory();\r\n\r\n    // Retrain ML model with new data\r\n    if (healingRecord.context) {\r\n      const element = await this.findElementByLocator(healingRecord.healedLocator);\r\n      if (element) {\r\n        const features = this.extractFeatures(element, healingRecord.healedLocator);\r\n        this.mlModel.train([{ features, label: success ? 1 : 0 }]);\r\n        this.saveModel();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate alternative locators using multiple strategies\r\n   */\r\n  private async generateAlternativeLocators(element: Element): Promise<Array<{ locator: string; strategy: string }>> {\r\n    const alternatives: Array<{ locator: string; strategy: string }> = [];\r\n\r\n    // Strategy 1: Test ID (highest priority)\r\n    const testId = element.getAttribute('data-testid') || element.getAttribute('data-test');\r\n    if (testId) {\r\n      alternatives.push({ locator: `[data-testid=\"${testId}\"]`, strategy: 'testid' });\r\n    }\r\n\r\n    // Strategy 2: ID (if not dynamic)\r\n    if (element.id && !this.isDynamicId(element.id)) {\r\n      alternatives.push({ locator: `#${element.id}`, strategy: 'id' });\r\n    }\r\n\r\n    // Strategy 3: ARIA attributes\r\n    const ariaLabel = element.getAttribute('aria-label');\r\n    if (ariaLabel) {\r\n      alternatives.push({ locator: `[aria-label=\"${ariaLabel}\"]`, strategy: 'aria' });\r\n    }\r\n\r\n    // Strategy 4: Role\r\n    const role = element.getAttribute('role');\r\n    if (role) {\r\n      alternatives.push({ locator: `[role=\"${role}\"]`, strategy: 'role' });\r\n    }\r\n\r\n    // Strategy 5: Name attribute\r\n    const name = element.getAttribute('name');\r\n    if (name) {\r\n      alternatives.push({ locator: `[name=\"${name}\"]`, strategy: 'name' });\r\n    }\r\n\r\n    // Strategy 6: Placeholder\r\n    const placeholder = element.getAttribute('placeholder');\r\n    if (placeholder) {\r\n      alternatives.push({ locator: `[placeholder=\"${placeholder}\"]`, strategy: 'placeholder' });\r\n    }\r\n\r\n    // Strategy 7: Text content (if short)\r\n    const text = element.textContent?.trim();\r\n    if (text && text.length < 50) {\r\n      alternatives.push({ locator: `${element.tagName.toLowerCase()}:has-text(\"${text}\")`, strategy: 'text' });\r\n    }\r\n\r\n    // Strategy 8: CSS class (if not dynamic)\r\n    if (element.className && !this.isDynamicClass(element.className)) {\r\n      const firstClass = element.className.split(' ')[0];\r\n      alternatives.push({ locator: `${element.tagName.toLowerCase()}.${firstClass}`, strategy: 'css' });\r\n    }\r\n\r\n    // Strategy 9: XPath with context\r\n    const xpath = this.generateSmartXPath(element);\r\n    alternatives.push({ locator: xpath, strategy: 'xpath' });\r\n\r\n    return alternatives;\r\n  }\r\n\r\n  /**\r\n   * Get healing statistics and success rates\r\n   */\r\n  async getHealingStatistics(): Promise<{\r\n    totalHealings: number;\r\n    successRate: number;\r\n    autoHealRate: number;\r\n    rollbackRate: number;\r\n    averageConfidence: number;\r\n    topStrategies: Array<{ strategy: string; count: number; successRate: number }>;\r\n  }> {\r\n    const allHealings: HealingHistory[] = [];\r\n\r\n    for (const history of this.healingHistory.values()) {\r\n      allHealings.push(...history);\r\n    }\r\n\r\n    const totalHealings = allHealings.length;\r\n    const successfulHealings = allHealings.filter(h => h.success).length;\r\n    const successRate = totalHealings > 0 ? successfulHealings / totalHealings : 0;\r\n\r\n    const autoAppliedHealings = allHealings.filter(h => h.confidence >= this.config.confidenceThreshold).length;\r\n    const autoHealRate = totalHealings > 0 ? autoAppliedHealings / totalHealings : 0;\r\n\r\n    const rolledBackHealings = allHealings.filter(h => h.rollback).length;\r\n    const rollbackRate = totalHealings > 0 ? rolledBackHealings / totalHealings : 0;\r\n\r\n    const avgConfidence = totalHealings > 0\r\n      ? allHealings.reduce((sum, h) => sum + h.confidence, 0) / totalHealings\r\n      : 0;\r\n\r\n    // Calculate strategy statistics\r\n    const strategyStats = new Map<string, { count: number; successes: number }>();\r\n\r\n    for (const healing of allHealings) {\r\n      const strategy = this.extractStrategyFromLocator(healing.healedLocator);\r\n      if (!strategyStats.has(strategy)) {\r\n        strategyStats.set(strategy, { count: 0, successes: 0 });\r\n      }\r\n      const stats = strategyStats.get(strategy)!;\r\n      stats.count++;\r\n      if (healing.success) {\r\n        stats.successes++;\r\n      }\r\n    }\r\n\r\n    const topStrategies = Array.from(strategyStats.entries())\r\n      .map(([strategy, stats]) => ({\r\n        strategy,\r\n        count: stats.count,\r\n        successRate: stats.count > 0 ? stats.successes / stats.count : 0\r\n      }))\r\n      .sort((a, b) => b.count - a.count)\r\n      .slice(0, 5);\r\n\r\n    return {\r\n      totalHealings,\r\n      successRate,\r\n      autoHealRate,\r\n      rollbackRate,\r\n      averageConfidence: avgConfidence,\r\n      topStrategies\r\n    };\r\n  }\r\n\r\n  // Helper methods\r\n  private getElementDepth(element: Element): number {\r\n    let depth = 0;\r\n    let current: Element | null = element;\r\n    while (current.parentElement) {\r\n      depth++;\r\n      current = current.parentElement;\r\n    }\r\n    return depth;\r\n  }\r\n\r\n  private isUniqueColor(color: string): boolean {\r\n    // Simple heuristic - unique colors are less common\r\n    const commonColors = ['#000000', '#ffffff', '#808080', '#c0c0c0'];\r\n    return !commonColors.includes(color.toLowerCase());\r\n  }\r\n\r\n  private isUniqueSize(width: number, height: number): boolean {\r\n    // Check if size is uncommon (not standard button/input sizes)\r\n    const commonSizes = [\r\n      { w: 200, h: 30 },  // Standard button\r\n      { w: 150, h: 30 },  // Small button\r\n      { w: 300, h: 150 }, // Standard input\r\n    ];\r\n\r\n    return !commonSizes.some(size =>\r\n      Math.abs(width - size.w) < 10 && Math.abs(height - size.h) < 10\r\n    );\r\n  }\r\n\r\n  private async canvasToHash(canvas: HTMLCanvasElement): Promise<string> {\r\n    const dataUrl = canvas.toDataURL();\r\n    return this.hashString(dataUrl);\r\n  }\r\n\r\n  private hashString(str: string): string {\r\n    let hash = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n      const char = str.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash; // Convert to 32-bit integer\r\n    }\r\n    return Math.abs(hash).toString(16);\r\n  }\r\n\r\n  private compareHashes(hash1: string, hash2: string): number {\r\n    // Simple hash similarity (can be improved with more sophisticated algorithms)\r\n    const len = Math.max(hash1.length, hash2.length);\r\n    let matches = 0;\r\n    for (let i = 0; i < len; i++) {\r\n      if (hash1[i] === hash2[i]) matches++;\r\n    }\r\n    return matches / len;\r\n  }\r\n\r\n  private calculateSizeSimilarity(fp1: VisualFingerprint, fp2: VisualFingerprint): number {\r\n    const widthDiff = Math.abs(fp1.width - fp2.width) / Math.max(fp1.width, fp2.width);\r\n    const heightDiff = Math.abs(fp1.height - fp2.height) / Math.max(fp1.height, fp2.height);\r\n    return 1 - (widthDiff + heightDiff) / 2;\r\n  }\r\n\r\n  private calculateStyleSimilarity(fp1: VisualFingerprint, fp2: VisualFingerprint): number {\r\n    const colorSimilarity = fp1.color === fp2.color ? 1 : 0;\r\n    const bgSimilarity = fp1.backgroundColor === fp2.backgroundColor ? 1 : 0;\r\n    const fontSimilarity = fp1.fontFamily === fp2.fontFamily ? 1 : 0;\r\n    return (colorSimilarity + bgSimilarity + fontSimilarity) / 3;\r\n  }\r\n\r\n  private calculatePositionSimilarity(fp1: VisualFingerprint, fp2: VisualFingerprint): number {\r\n    const distance = Math.sqrt(\r\n      Math.pow(fp1.x - fp2.x, 2) + Math.pow(fp1.y - fp2.y, 2)\r\n    );\r\n    // Normalize by screen size (assuming 1920x1080)\r\n    const maxDistance = Math.sqrt(Math.pow(1920, 2) + Math.pow(1080, 2));\r\n    return 1 - (distance / maxDistance);\r\n  }\r\n\r\n  private calculateTextSimilarity(text1: string, text2: string): number {\r\n    // Simple Levenshtein distance\r\n    const matrix = Array(text2.length + 1).fill(null).map(() => Array(text1.length + 1).fill(null));\r\n\r\n    for (let i = 0; i <= text2.length; i++) matrix[i][0] = i;\r\n    for (let j = 0; j <= text1.length; j++) matrix[0][j] = j;\r\n\r\n    for (let i = 1; i <= text2.length; i++) {\r\n      for (let j = 1; j <= text1.length; j++) {\r\n        const cost = text1[j - 1] === text2[i - 1] ? 0 : 1;\r\n        matrix[i][j] = Math.min(\r\n          matrix[i - 1][j] + 1,\r\n          matrix[i][j - 1] + 1,\r\n          matrix[i - 1][j - 1] + cost\r\n        );\r\n      }\r\n    }\r\n\r\n    const distance = matrix[text2.length][text1.length];\r\n    const maxLength = Math.max(text1.length, text2.length);\r\n    return maxLength > 0 ? 1 - (distance / maxLength) : 1;\r\n  }\r\n\r\n  private generateElementId(element: Element): string {\r\n    return `${element.tagName.toLowerCase()}-${element.id || 'no-id'}-${Date.now()}`;\r\n  }\r\n\r\n  private generateHistoryKey(locator: string, context: { url: string }): string {\r\n    return `${locator}-${context.url}`;\r\n  }\r\n\r\n  private generateId(): string {\r\n    return Math.random().toString(36).substr(2, 9);\r\n  }\r\n\r\n  private isDynamicId(id: string): boolean {\r\n    return /\\d{6,}/.test(id) ||\r\n           /timestamp|uid|uuid|random/i.test(id) ||\r\n           /css-\\w+/.test(id);\r\n  }\r\n\r\n  private isDynamicClass(className: string): boolean {\r\n    return /^css-\\w+/.test(className) ||\r\n           /\\d{6,}/.test(className);\r\n  }\r\n\r\n  private generateSmartXPath(element: Element): string {\r\n    const path: string[] = [];\r\n    let current: Element | null = element;\r\n\r\n    while (current && current.nodeType === Node.ELEMENT_NODE) {\r\n      const tagName = current.tagName.toLowerCase();\r\n      const index = Array.from(current.parentElement?.children || [])\r\n        .filter(el => current && el.tagName === current.tagName)\r\n        .indexOf(current) + 1;\r\n\r\n      if (current.id && !this.isDynamicId(current.id)) {\r\n        path.push(`//*[@id=\"${current.id}\"]`);\r\n        break;\r\n      } else {\r\n        path.push(`/${tagName}[${index}]`);\r\n      }\r\n\r\n      current = current.parentElement;\r\n    }\r\n\r\n    return path.reverse().join('');\r\n  }\r\n\r\n  private extractStrategyFromLocator(locator: string): string {\r\n    if (locator.startsWith('[data-testid=')) return 'testid';\r\n    if (locator.startsWith('#')) return 'id';\r\n    if (locator.startsWith('[aria-label=')) return 'aria';\r\n    if (locator.startsWith('[role=')) return 'role';\r\n    if (locator.startsWith('[name=')) return 'name';\r\n    if (locator.startsWith('[placeholder=')) return 'placeholder';\r\n    if (locator.includes(':has-text(')) return 'text';\r\n    if (locator.startsWith('//')) return 'xpath';\r\n    return 'css';\r\n  }\r\n\r\n  private async findElementByLocator(locator: string): Promise<Element | null> {\r\n    try {\r\n      // Simple locator parsing (can be enhanced)\r\n      if (locator.startsWith('#')) {\r\n        return document.querySelector(locator);\r\n      } else if (locator.startsWith('[')) {\r\n        return document.querySelector(locator);\r\n      } else if (locator.includes(':has-text(')) {\r\n        const text = locator.match(/:has-text\\(\"([^\"]+)\"\\)/)?.[1];\r\n        if (text) {\r\n          const elements = Array.from(document.querySelectorAll('*'));\r\n          return elements.find(el => el.textContent?.includes(text)) || null;\r\n        }\r\n      } else if (locator.startsWith('//')) {\r\n        return document.evaluate(locator, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null)?.singleNodeValue as Element;\r\n      }\r\n\r\n      return document.querySelector(locator);\r\n    } catch {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  private async markLocatorUnreliable(locator: string): Promise<void> {\r\n    // Store unreliable locators in Chrome storage\r\n    const unreliable = await chrome.storage.local.get('unreliable_locators') || { unreliable_locators: [] };\r\n    unreliable.unreliable_locators.push({\r\n      locator,\r\n      timestamp: new Date(),\r\n      reason: 'Auto-rollback due to repeated failures'\r\n    });\r\n    await chrome.storage.local.set(unreliable);\r\n  }\r\n\r\n  private async loadModel(): Promise<void> {\r\n    try {\r\n      const stored = await chrome.storage.local.get('ai_healing_model');\r\n      if (stored.ai_healing_model) {\r\n        this.mlModel.load(stored.ai_healing_model);\r\n      }\r\n    } catch {\r\n      // Use default model if loading fails\r\n      console.log('Using default ML model');\r\n    }\r\n  }\r\n\r\n  private async saveModel(): Promise<void> {\r\n    try {\r\n      await chrome.storage.local.set({\r\n        ai_healing_model: this.mlModel.save()\r\n      });\r\n    } catch (error) {\r\n      console.error('Failed to save ML model:', error);\r\n    }\r\n  }\r\n\r\n  private async loadHistory(): Promise<void> {\r\n    try {\r\n      const stored = await chrome.storage.local.get('healing_history');\r\n      if (stored.healing_history) {\r\n        this.healingHistory = new Map(Object.entries(stored.healing_history));\r\n      }\r\n    } catch {\r\n      console.log('No healing history found');\r\n    }\r\n  }\r\n\r\n  private async saveHistory(): Promise<void> {\r\n    try {\r\n      const historyObject = Object.fromEntries(this.healingHistory);\r\n      await chrome.storage.local.set({ healing_history: historyObject });\r\n    } catch (error) {\r\n      console.error('Failed to save healing history:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Configure auto-healing behavior\r\n   */\r\n  updateConfig(newConfig: Partial<AutoHealingConfig>): void {\r\n    this.config = { ...this.config, ...newConfig };\r\n    chrome.storage.local.set({ ai_healing_config: this.config });\r\n  }\r\n\r\n  /**\r\n   * Get current configuration\r\n   */\r\n  getConfig(): AutoHealingConfig {\r\n    return { ...this.config };\r\n  }\r\n}\r\n\r\n/**\r\n * Simple ML Model implementation\r\n * In production, replace with TensorFlow.js or similar\r\n */\r\nclass SimpleMLModel implements MLModel {\r\n  private weights: number[] = [];\r\n  private bias: number = 0;\r\n  private isTrained: boolean = false;\r\n\r\n  predict(features: LocatorFeatures): number {\r\n    if (!this.isTrained) {\r\n      // Default prediction based on heuristics\r\n      return this.heuristicPrediction(features);\r\n    }\r\n\r\n    // Simple linear regression\r\n    const featureVector = this.featuresToVector(features);\r\n    let sum = this.bias;\r\n\r\n    for (let i = 0; i < featureVector.length; i++) {\r\n      sum += featureVector[i] * (this.weights[i] || 0);\r\n    }\r\n\r\n    // Sigmoid activation\r\n    return 1 / (1 + Math.exp(-sum));\r\n  }\r\n\r\n  train(trainingData: { features: LocatorFeatures; label: number }[]): void {\r\n    if (trainingData.length === 0) return;\r\n\r\n    // Simple gradient descent\r\n    const learningRate = 0.01;\r\n    const epochs = 100;\r\n\r\n    // Initialize weights\r\n    const featureCount = this.featuresToVector(trainingData[0].features).length;\r\n    this.weights = Array(featureCount).fill(0.1);\r\n    this.bias = 0;\r\n\r\n    for (let epoch = 0; epoch < epochs; epoch++) {\r\n      for (const sample of trainingData) {\r\n        const featureVector = this.featuresToVector(sample.features);\r\n\r\n        // Forward pass\r\n        let prediction = this.bias;\r\n        for (let i = 0; i < featureVector.length; i++) {\r\n          prediction += featureVector[i] * this.weights[i];\r\n        }\r\n        prediction = 1 / (1 + Math.exp(-prediction));\r\n\r\n        // Backward pass\r\n        const error = sample.label - prediction;\r\n\r\n        // Update weights\r\n        for (let i = 0; i < featureVector.length; i++) {\r\n          this.weights[i] += learningRate * error * featureVector[i];\r\n        }\r\n        this.bias += learningRate * error;\r\n      }\r\n    }\r\n\r\n    this.isTrained = true;\r\n  }\r\n\r\n  save(): any {\r\n    return {\r\n      weights: this.weights,\r\n      bias: this.bias,\r\n      isTrained: this.isTrained\r\n    };\r\n  }\r\n\r\n  load(data?: any): void {\r\n    if (data && data.weights) {\r\n      this.weights = data.weights;\r\n      this.bias = data.bias || 0;\r\n      this.isTrained = data.isTrained || false;\r\n    }\r\n  }\r\n\r\n  private heuristicPrediction(features: LocatorFeatures): number {\r\n    let score = 0.5;\r\n\r\n    // Boost for stable identifiers\r\n    if (features.hasTestId) score += 0.3;\r\n    if (features.hasId && !features.hasNumericId) score += 0.25;\r\n    if (features.hasAriaLabel) score += 0.2;\r\n    if (features.hasRole) score += 0.15;\r\n\r\n    // Penalize dynamic patterns\r\n    if (features.hasNumericId) score -= 0.3;\r\n    if (features.hasCssModuleClass) score -= 0.2;\r\n    if (features.hasTimestamp) score -= 0.15;\r\n    if (features.hasUuid) score -= 0.25;\r\n\r\n    // Boost for interactive elements\r\n    if (features.isClickable) score += 0.1;\r\n\r\n    // Penalize generic elements\r\n    if (features.elementType === 'div' || features.elementType === 'span') {\r\n      if (!features.hasId && !features.hasTestId && !features.hasClass) {\r\n        score -= 0.2;\r\n      }\r\n    }\r\n\r\n    return Math.max(0, Math.min(1, score));\r\n  }\r\n\r\n  private featuresToVector(features: LocatorFeatures): number[] {\r\n    return [\r\n      features.hasId ? 1 : 0,\r\n      features.hasTestId ? 1 : 0,\r\n      features.hasAriaLabel ? 1 : 0,\r\n      features.hasRole ? 1 : 0,\r\n      features.hasName ? 1 : 0,\r\n      features.hasPlaceholder ? 1 : 0,\r\n      features.hasText ? 1 : 0,\r\n      features.hasClass ? 1 : 0,\r\n      features.textLength / 100, // Normalized\r\n      features.textWordCount / 20, // Normalized\r\n      features.hasNumericText ? 1 : 0,\r\n      features.hasSpecialChars ? 1 : 0,\r\n      features.depth / 10, // Normalized\r\n      features.siblingCount / 10, // Normalized\r\n      features.indexAmongSiblings / 10, // Normalized\r\n      features.isVisible ? 1 : 0,\r\n      features.isClickable ? 1 : 0,\r\n      features.hasUniqueColor ? 1 : 0,\r\n      features.hasUniqueSize ? 1 : 0,\r\n      features.hasNumericId ? 1 : 0,\r\n      features.hasCssModuleClass ? 1 : 0,\r\n      features.hasTimestamp ? 1 : 0,\r\n      features.hasUuid ? 1 : 0,\r\n      features.hasRandomId ? 1 : 0\r\n    ];\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const aiSelfHealingService = new AISelfHealingService();\r\n","/**\r\n * Copyright (c) Rui Figueira.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nimport { aiSelfHealingService } from './aiSelfHealingService';\r\n\r\nexport interface LocatorInfo {\r\n  locator: string;\r\n  type: 'id' | 'css' | 'xpath' | 'testid' | 'name' | 'aria' | 'role' | 'text' | 'placeholder';\r\n  elementTag?: string;\r\n  elementText?: string;\r\n  confidence?: number;\r\n  stability?: number;\r\n  aiEnhanced?: boolean;\r\n  visualSimilarity?: number;\r\n}\r\n\r\nexport interface HealingSuggestion {\r\n  id: string;\r\n  brokenLocator: string;\r\n  validLocator: string;\r\n  confidence: number;\r\n  stability: number;\r\n  status: 'pending' | 'approved' | 'rejected';\r\n  createdAt: Date;\r\n  lastUsed?: Date;\r\n  successCount?: number;\r\n  failureCount?: number;\r\n  reason?: string;\r\n  aiEnhanced?: boolean;\r\n  visualSimilarity?: number;\r\n}\r\n\r\nexport class SelfHealingService {\r\n  private suggestions: Map<string, HealingSuggestion[]> = new Map();\r\n  private locatorStrategies = [\r\n    { type: 'testid', priority: 1, stability: 0.95 },\r\n    { type: 'id', priority: 2, stability: 0.90 },\r\n    { type: 'aria', priority: 3, stability: 0.85 },\r\n    { type: 'role', priority: 4, stability: 0.80 },\r\n    { type: 'name', priority: 5, stability: 0.75 },\r\n    { type: 'placeholder', priority: 6, stability: 0.70 },\r\n    { type: 'text', priority: 7, stability: 0.65 },\r\n    { type: 'css', priority: 8, stability: 0.50 },\r\n    { type: 'xpath', priority: 9, stability: 0.40 }\r\n  ];\r\n\r\n  // AI integration flag\r\n  private aiEnabled: boolean = true;\r\n\r\n  /**\r\n   * Enable/disable AI enhancement\r\n   */\r\n  setAIEnabled(enabled: boolean): void {\r\n    this.aiEnabled = enabled;\r\n  }\r\n\r\n  /**\r\n   * Check if AI is enabled\r\n   */\r\n  isAIEnabled(): boolean {\r\n    return this.aiEnabled;\r\n  }\r\n\r\n  /**\r\n   * Calculate comprehensive confidence score with AI enhancement\r\n   */\r\n  private async calculateConfidence(\r\n    type: string,\r\n    locator: string,\r\n    element: { tag: string; id?: string; className?: string; attributes: Record<string, string> }\r\n  ): Promise<number> {\r\n    const strategy = this.locatorStrategies.find(s => s.type === type);\r\n    const stabilityScore = strategy?.stability || 0.5;\r\n\r\n    // Calculate uniqueness score\r\n    let uniquenessScore = 0.5;\r\n    if (type === 'id' || type === 'testid') uniquenessScore += 0.3;\r\n    if (type === 'aria' || type === 'role') uniquenessScore += 0.2;\r\n    if (locator.includes('div') || locator.includes('span')) uniquenessScore -= 0.2;\r\n    if (element.attributes['data-testid'] || element.id) uniquenessScore += 0.2;\r\n\r\n    uniquenessScore = Math.min(1.0, Math.max(0.0, uniquenessScore));\r\n\r\n    // Base confidence calculation\r\n    let confidence = stabilityScore * 0.6 + uniquenessScore * 0.4;\r\n\r\n    // AI enhancement if enabled\r\n    if (this.aiEnabled) {\r\n      try {\r\n        // Create a mock element for AI prediction\r\n        const mockElement = document.createElement(element.tag);\r\n        if (element.id) mockElement.id = element.id;\r\n        if (element.className) mockElement.className = element.className;\r\n\r\n        // Set attributes\r\n        Object.entries(element.attributes).forEach(([key, value]) => {\r\n          mockElement.setAttribute(key, value);\r\n        });\r\n\r\n        const aiPrediction = await aiSelfHealingService.predictLocatorSuccess(mockElement, locator);\r\n        // Blend AI prediction with traditional scoring\r\n        confidence = (confidence * 0.7) + (aiPrediction.confidence * 0.3);\r\n      } catch (error) {\r\n        // Fallback to traditional scoring if AI fails\r\n        console.warn('AI prediction failed, using traditional scoring:', error);\r\n      }\r\n    }\r\n\r\n    return confidence;\r\n  }\r\n\r\n  /**\r\n   * Record a locator failure and suggest alternatives\r\n   */\r\n  async recordFailure(brokenLocator: LocatorInfo, validLocator?: LocatorInfo): Promise<HealingSuggestion | null> {\r\n    try {\r\n      // In a browser extension, we'll store suggestions in chrome.storage\r\n      const scriptId = 'current-script'; // This would be dynamic in a real implementation\r\n      const suggestions = this.suggestions.get(scriptId) || [];\r\n\r\n      if (validLocator) {\r\n        // Check if this combination already exists\r\n        const existing = suggestions.find(s =>\r\n          s.brokenLocator === brokenLocator.locator &&\r\n          s.validLocator === validLocator.locator\r\n        );\r\n\r\n        if (existing) {\r\n          // Update usage count (simplified for browser extension)\r\n          return existing;\r\n        }\r\n\r\n        // Create new self-healing suggestion\r\n        const suggestion: HealingSuggestion = {\r\n          id: Math.random().toString(36).substr(2, 9),\r\n          brokenLocator: brokenLocator.locator,\r\n          validLocator: validLocator.locator,\r\n          confidence: validLocator.confidence || 0.5,\r\n          stability: 0.8, // Default stability\r\n          status: 'pending',\r\n          createdAt: new Date(),\r\n          aiEnhanced: validLocator.aiEnhanced || false\r\n        };\r\n\r\n        suggestions.push(suggestion);\r\n        this.suggestions.set(scriptId, suggestions);\r\n\r\n        // Store in chrome.storage for persistence\r\n        await chrome.storage.local.set({\r\n          [`healing_suggestions_${scriptId}`]: suggestions\r\n        });\r\n\r\n        return suggestion;\r\n      }\r\n\r\n      return null;\r\n    } catch (error) {\r\n      console.error('Error recording locator failure:', error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get self-healing suggestions for a script\r\n   */\r\n  async getSuggestions(): Promise<HealingSuggestion[]> {\r\n    try {\r\n      const scriptId = 'current-script'; // This would be dynamic in a real implementation\r\n      const result = await chrome.storage.local.get([`healing_suggestions_${scriptId}`]);\r\n      return result[`healing_suggestions_${scriptId}`] || [];\r\n    } catch (error) {\r\n      console.error('Error getting suggestions:', error);\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Approve a self-healing suggestion\r\n   */\r\n  async approveSuggestion(id: string): Promise<boolean> {\r\n    try {\r\n      const scriptId = 'current-script'; // This would be dynamic in a real implementation\r\n      const suggestions = await this.getSuggestions();\r\n      const suggestion = suggestions.find(s => s.id === id);\r\n\r\n      if (suggestion) {\r\n        suggestion.status = 'approved';\r\n        suggestion.confidence = Math.min(1.0, suggestion.confidence + 0.1);\r\n\r\n        await chrome.storage.local.set({\r\n          [`healing_suggestions_${scriptId}`]: suggestions\r\n        });\r\n\r\n        // Record success in AI service if AI-enhanced\r\n        if (suggestion.aiEnhanced) {\r\n          try {\r\n            await aiSelfHealingService.recordHealingResult(id, true);\r\n          } catch (error) {\r\n            console.warn('Failed to record AI healing result:', error);\r\n          }\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    } catch (error) {\r\n      console.error('Error approving suggestion:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reject a self-healing suggestion\r\n   */\r\n  async rejectSuggestion(id: string): Promise<boolean> {\r\n    try {\r\n      const scriptId = 'current-script'; // This would be dynamic in a real implementation\r\n      const suggestions = await this.getSuggestions();\r\n      const suggestion = suggestions.find(s => s.id === id);\r\n\r\n      if (suggestion) {\r\n        suggestion.status = 'rejected';\r\n\r\n        await chrome.storage.local.set({\r\n          [`healing_suggestions_${scriptId}`]: suggestions\r\n        });\r\n\r\n        // Record failure in AI service if AI-enhanced\r\n        if (suggestion.aiEnhanced) {\r\n          try {\r\n            await aiSelfHealingService.recordHealingResult(id, false);\r\n          } catch (error) {\r\n            console.warn('Failed to record AI healing result:', error);\r\n          }\r\n        }\r\n\r\n        return true;\r\n      }\r\n\r\n      return false;\r\n    } catch (error) {\r\n      console.error('Error rejecting suggestion:', error);\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Try to find element using alternative locators with AI enhancement\r\n   */\r\n  async findAlternativeLocator(\r\n    element: { tag: string; id?: string; className?: string; attributes: Record<string, string> }\r\n  ): Promise<LocatorInfo | null> {\r\n    const locators: LocatorInfo[] = [];\r\n\r\n    // Generate all possible locators\r\n    for (const { type } of this.locatorStrategies) {\r\n      let locator: LocatorInfo | null = null;\r\n\r\n      switch (type) {\r\n        case 'id':\r\n          if (element.id && !element.id.match(/\\d{6,}/)) {\r\n            locator = { locator: `#${element.id}`, type: 'id' };\r\n          }\r\n          break;\r\n\r\n        case 'testid':\r\n          const testId = element.attributes['data-testid'] || element.attributes['data-test'];\r\n          if (testId) {\r\n            locator = { locator: `[data-testid=\"${testId}\"]`, type: 'testid' };\r\n          }\r\n          break;\r\n\r\n        case 'aria':\r\n          const ariaLabel = element.attributes['aria-label'];\r\n          if (ariaLabel) {\r\n            locator = { locator: `[aria-label=\"${ariaLabel}\"]`, type: 'aria' };\r\n          }\r\n          break;\r\n\r\n        case 'role':\r\n          const role = element.attributes.role;\r\n          if (role) {\r\n            locator = { locator: `[role=\"${role}\"]`, type: 'role' };\r\n          }\r\n          break;\r\n\r\n        case 'name':\r\n          if (element.attributes.name) {\r\n            locator = { locator: `[name=\"${element.attributes.name}\"]`, type: 'name' };\r\n          }\r\n          break;\r\n\r\n        case 'placeholder':\r\n          const placeholder = element.attributes.placeholder;\r\n          if (placeholder) {\r\n            locator = { locator: `[placeholder=\"${placeholder}\"]`, type: 'placeholder' };\r\n          }\r\n          break;\r\n\r\n        case 'text':\r\n          // Would need element text content, skip for now\r\n          break;\r\n\r\n        case 'css':\r\n          if (element.className && !element.className.match(/\\d{6,}/)) {\r\n            locator = { locator: `.${element.className.split(' ')[0]}`, type: 'css' };\r\n          }\r\n          break;\r\n\r\n        case 'xpath':\r\n          locator = { locator: `//${element.tag}`, type: 'xpath' };\r\n          break;\r\n      }\r\n\r\n      if (locator) {\r\n        locator.confidence = await this.calculateConfidence(type, locator.locator, element);\r\n        locators.push(locator);\r\n      }\r\n    }\r\n\r\n    // AI enhancement if enabled\r\n    if (this.aiEnabled && locators.length > 0) {\r\n      try {\r\n        // Create a mock element for AI prediction\r\n        const mockElement = document.createElement(element.tag);\r\n        if (element.id) mockElement.id = element.id;\r\n        if (element.className) mockElement.className = element.className;\r\n\r\n        // Set attributes\r\n        Object.entries(element.attributes).forEach(([key, value]) => {\r\n          mockElement.setAttribute(key, value);\r\n        });\r\n\r\n        // Get AI predictions for each locator\r\n        const aiEnhancedLocators = await Promise.all(\r\n          locators.map(async (locator) => {\r\n            const aiPrediction = await aiSelfHealingService.predictLocatorSuccess(mockElement, locator.locator);\r\n            return {\r\n              ...locator,\r\n              confidence: aiPrediction.confidence,\r\n              aiEnhanced: true\r\n            };\r\n          })\r\n        );\r\n\r\n        // Sort by AI-enhanced confidence and return the best\r\n        aiEnhancedLocators.sort((a, b) => (b.confidence || 0) - (a.confidence || 0));\r\n        return aiEnhancedLocators[0];\r\n      } catch (error) {\r\n        console.warn('AI enhancement failed, using traditional scoring:', error);\r\n      }\r\n    }\r\n\r\n    // Sort by traditional confidence and return the best\r\n    locators.sort((a, b) => (b.confidence || 0) - (a.confidence || 0));\r\n    return locators.length > 0 ? locators[0] : null;\r\n  }\r\n\r\n  /**\r\n   * Update locator strategy priority\r\n   */\r\n  async updateStrategyPriority(strategies: Array<{ type: string; priority: number; stability: number }>): Promise<void> {\r\n    this.locatorStrategies = strategies.sort((a, b) => a.priority - b.priority);\r\n    await chrome.storage.local.set({ locator_strategies: strategies });\r\n  }\r\n\r\n  /**\r\n   * Load saved strategies from storage\r\n   */\r\n  async loadStrategies(): Promise<void> {\r\n    try {\r\n      const result = await chrome.storage.local.get(['locator_strategies']);\r\n      if (result.locator_strategies) {\r\n        this.locatorStrategies = result.locator_strategies;\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading strategies:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect unstable locators with AI pattern recognition\r\n   */\r\n  async detectUnstableLocator(locator: string, element?: Element): Promise<{\r\n    isUnstable: boolean;\r\n    reason?: string;\r\n    suggestions?: LocatorInfo[];\r\n    aiDetected?: boolean;\r\n  }> {\r\n    const unstablePatterns = [\r\n      { pattern: /\\d{6,}/, reason: 'Contains long numeric ID (likely dynamic)' },\r\n      { pattern: /^\\.(css|sc|jss)-\\w+/, reason: 'CSS-in-JS class (changes on build)' },\r\n      { pattern: /timestamp|uid|uuid|random/i, reason: 'Contains dynamic identifier' },\r\n      { pattern: /\\[\\d+\\]/, reason: 'Uses array index (fragile)' }\r\n    ];\r\n\r\n    // Traditional pattern detection\r\n    for (const { pattern, reason } of unstablePatterns) {\r\n      if (pattern.test(locator)) {\r\n        return { isUnstable: true, reason, aiDetected: false };\r\n      }\r\n    }\r\n\r\n    // AI-enhanced detection if enabled and element is provided\r\n    if (this.aiEnabled && element) {\r\n      try {\r\n        // Get AI prediction instead of direct feature extraction\r\n        const aiPrediction = await aiSelfHealingService.predictLocatorSuccess(element, locator);\r\n        const features = aiPrediction.features;\r\n\r\n        // Check if AI detects instability\r\n        if (features.hasNumericId || features.hasCssModuleClass ||\r\n            features.hasTimestamp || features.hasUuid || features.hasRandomId) {\r\n          return {\r\n            isUnstable: true,\r\n            reason: 'AI-detected dynamic pattern',\r\n            aiDetected: true\r\n          };\r\n        }\r\n      } catch (error) {\r\n        console.warn('AI instability detection failed:', error);\r\n      }\r\n    }\r\n\r\n    return { isUnstable: false };\r\n  }\r\n\r\n  /**\r\n   * Auto-cleanup old suggestions\r\n   */\r\n  async cleanupSuggestions(daysOld: number = 30): Promise<number> {\r\n    const cutoffDate = new Date();\r\n    cutoffDate.setDate(cutoffDate.getDate() - daysOld);\r\n\r\n    let cleanedCount = 0;\r\n\r\n    for (const [scriptId, suggestions] of this.suggestions.entries()) {\r\n      const filtered = suggestions.filter(s => {\r\n        const shouldRemove = (\r\n          s.status === 'rejected' &&\r\n          s.createdAt < cutoffDate\r\n        );\r\n        if (shouldRemove) cleanedCount++;\r\n        return !shouldRemove;\r\n      });\r\n\r\n      this.suggestions.set(scriptId, filtered);\r\n      await chrome.storage.local.set({\r\n        [`healing_suggestions_${scriptId}`]: filtered\r\n      });\r\n    }\r\n\r\n    return cleanedCount;\r\n  }\r\n\r\n  /**\r\n   * Get enhanced healing statistics with AI metrics\r\n   */\r\n  async getStatistics(): Promise<{\r\n    total: number;\r\n    pending: number;\r\n    approved: number;\r\n    rejected: number;\r\n    averageConfidence: number;\r\n    aiEnhancedCount: number;\r\n    aiSuccessRate: number;\r\n    visualSimilarityAvg: number;\r\n  }> {\r\n    const allSuggestions: HealingSuggestion[] = [];\r\n\r\n    for (const suggestions of this.suggestions.values()) {\r\n      allSuggestions.push(...suggestions);\r\n    }\r\n\r\n    const total = allSuggestions.length;\r\n    const pending = allSuggestions.filter(s => s.status === 'pending').length;\r\n    const approved = allSuggestions.filter(s => s.status === 'approved').length;\r\n    const rejected = allSuggestions.filter(s => s.status === 'rejected').length;\r\n\r\n    const avgConfidence = total > 0\r\n      ? allSuggestions.reduce((sum, s) => sum + s.confidence, 0) / total\r\n      : 0;\r\n\r\n    // AI-specific metrics\r\n    const aiEnhanced = allSuggestions.filter(s => s.aiEnhanced);\r\n    const aiEnhancedCount = aiEnhanced.length;\r\n    const aiSuccesses = aiEnhanced.reduce((sum, s) => sum + (s.successCount || 0), 0);\r\n    const aiAttempts = aiEnhanced.reduce((sum, s) =>\r\n      sum + (s.successCount || 0) + (s.failureCount || 0), 0\r\n    );\r\n    const aiSuccessRate = aiAttempts > 0 ? aiSuccesses / aiAttempts : 0;\r\n\r\n    // Visual similarity average\r\n    const withSimilarity = allSuggestions.filter(s => s.visualSimilarity !== undefined);\r\n    const visualSimilarityAvg = withSimilarity.length > 0\r\n      ? withSimilarity.reduce((sum, s) => sum + (s.visualSimilarity || 0), 0) / withSimilarity.length\r\n      : 0;\r\n\r\n    return {\r\n      total,\r\n      pending,\r\n      approved,\r\n      rejected,\r\n      averageConfidence: avgConfidence,\r\n      aiEnhancedCount,\r\n      aiSuccessRate,\r\n      visualSimilarityAvg\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Auto-heal locator using AI service\r\n   */\r\n  async autoHealLocator(\r\n    failedLocator: string,\r\n    element: Element,\r\n    context: { url: string; failureReason: string }\r\n  ): Promise<{\r\n    healedLocator: string;\r\n    confidence: number;\r\n    autoApplied: boolean;\r\n    requiresApproval: boolean;\r\n    aiEnhanced: boolean;\r\n  }> {\r\n    if (this.aiEnabled) {\r\n      try {\r\n        const aiResult = await aiSelfHealingService.autoHealLocator(failedLocator, element, context);\r\n\r\n        // Record the healing in traditional service as well\r\n        const suggestion: HealingSuggestion = {\r\n          id: Math.random().toString(36).substr(2, 9),\r\n          brokenLocator: failedLocator,\r\n          validLocator: aiResult.healedLocator,\r\n          confidence: aiResult.confidence,\r\n          stability: 0.8, // Default stability\r\n          status: aiResult.autoApplied ? 'approved' : 'pending',\r\n          createdAt: new Date(),\r\n          aiEnhanced: true\r\n        };\r\n\r\n        // Store suggestion\r\n        const scriptId = context.url; // Use URL as script identifier\r\n        if (!this.suggestions.has(scriptId)) {\r\n          this.suggestions.set(scriptId, []);\r\n        }\r\n        this.suggestions.get(scriptId)!.push(suggestion);\r\n\r\n        return {\r\n          ...aiResult,\r\n          aiEnhanced: true\r\n        };\r\n      } catch (error) {\r\n        console.warn('AI auto-healing failed, falling back to traditional:', error);\r\n      }\r\n    }\r\n\r\n    // Fallback to traditional healing\r\n    const elementInfo = {\r\n      tag: element.tagName.toLowerCase(),\r\n      id: element.id,\r\n      className: element.className,\r\n      attributes: {} as Record<string, string>\r\n    };\r\n\r\n    // Extract attributes\r\n    for (let i = 0; i < element.attributes.length; i++) {\r\n      const attr = element.attributes[i];\r\n      elementInfo.attributes[attr.name] = attr.value;\r\n    }\r\n\r\n    const alternative = await this.findAlternativeLocator(elementInfo);\r\n    if (alternative) {\r\n      return {\r\n        healedLocator: alternative.locator,\r\n        confidence: alternative.confidence || 0.5,\r\n        autoApplied: false,\r\n        requiresApproval: true,\r\n        aiEnhanced: false\r\n      };\r\n    }\r\n\r\n    throw new Error('No suitable alternative locator found');\r\n  }\r\n\r\n  /**\r\n   * Record healing result and sync with AI service\r\n   */\r\n  async recordHealingResult(\r\n    healingId: string,\r\n    success: boolean,\r\n    error?: string\r\n  ): Promise<void> {\r\n    // Find and update traditional healing record\r\n    for (const [scriptId, suggestions] of this.suggestions.entries()) {\r\n      const suggestion = suggestions.find(s => s.id === healingId);\r\n      if (suggestion) {\r\n        if (success) {\r\n          suggestion.successCount = (suggestion.successCount || 0) + 1;\r\n        } else {\r\n          suggestion.failureCount = (suggestion.failureCount || 0) + 1;\r\n        }\r\n        suggestion.lastUsed = new Date();\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Also record in AI service if AI-enhanced\r\n    try {\r\n      await aiSelfHealingService.recordHealingResult(healingId, success, error);\r\n    } catch (error) {\r\n      console.warn('Failed to record healing result in AI service:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get visual similarity between two elements\r\n   */\r\n  async getVisualSimilarity(element1: Element, element2: Element): Promise<number> {\r\n    if (this.aiEnabled) {\r\n      try {\r\n        return await aiSelfHealingService.compareVisualSimilarity(element1, element2);\r\n      } catch (error) {\r\n        console.warn('AI visual similarity failed:', error);\r\n      }\r\n    }\r\n\r\n    // Fallback to simple text comparison\r\n    const text1 = element1.textContent?.trim() || '';\r\n    const text2 = element2.textContent?.trim() || '';\r\n    return text1 === text2 ? 1.0 : 0.0;\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const selfHealingService = new SelfHealingService();\r\n","/**\r\n * Copyright (c) Rui Figueira.\r\n *\r\n * Licensed under the Apache License, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n * http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\nexport type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'HEAD' | 'OPTIONS';\r\n\r\nexport interface ApiRequest {\r\n  id: string;\r\n  method: HttpMethod;\r\n  url: string;\r\n  headers: Record<string, string>;\r\n  body?: string;\r\n  timestamp: number;\r\n}\r\n\r\nexport interface ApiResponse {\r\n  id: string;\r\n  requestId: string;\r\n  status: number;\r\n  statusText: string;\r\n  headers: Record<string, string>;\r\n  body?: string;\r\n  responseTime: number;\r\n  timestamp: number;\r\n}\r\n\r\nexport interface ApiAssertion {\r\n  id: string;\r\n  type: 'status' | 'header' | 'body' | 'json-path' | 'json-schema' | 'response-time';\r\n  operator: 'equals' | 'contains' | 'matches' | 'less-than' | 'greater-than' | 'exists';\r\n  expected: any;\r\n  actual?: any;\r\n  path?: string; // For JSON path assertions\r\n  passed?: boolean;\r\n  message?: string;\r\n}\r\n\r\nexport interface ApiTestCase {\r\n  id: string;\r\n  name: string;\r\n  description?: string;\r\n  request: ApiRequest;\r\n  assertions: ApiAssertion[];\r\n  response?: ApiResponse;\r\n  createdAt: Date;\r\n  updatedAt: Date;\r\n}\r\n\r\nexport interface ApiMock {\r\n  id: string;\r\n  name: string;\r\n  pattern: string; // URL pattern to match\r\n  method: HttpMethod;\r\n  response: {\r\n    status: number;\r\n    headers: Record<string, string>;\r\n    body: string;\r\n    delay?: number; // Delay in ms\r\n  };\r\n  enabled: boolean;\r\n}\r\n\r\nexport interface ContractTest {\r\n  id: string;\r\n  name: string;\r\n  provider: string; // API provider name\r\n  consumer: string; // API consumer name\r\n  endpoint: string;\r\n  method: HttpMethod;\r\n  requestSchema?: string; // JSON Schema\r\n  responseSchema?: string; // JSON Schema\r\n  examples: Array<{\r\n    request: any;\r\n    response: any;\r\n  }>;\r\n}\r\n\r\nexport interface PerformanceBenchmark {\r\n  id: string;\r\n  name: string;\r\n  endpoint: string;\r\n  method: HttpMethod;\r\n  targetResponseTime: number; // in ms\r\n  measurements: Array<{\r\n    timestamp: Date;\r\n    responseTime: number;\r\n    success: boolean;\r\n  }>;\r\n  avgResponseTime?: number;\r\n  minResponseTime?: number;\r\n  maxResponseTime?: number;\r\n  p50?: number;\r\n  p95?: number;\r\n  p99?: number;\r\n}\r\n\r\nexport class ApiTestingService {\r\n  private testCases: Map<string, ApiTestCase> = new Map();\r\n  private mocks: Map<string, ApiMock> = new Map();\r\n  private contracts: Map<string, ContractTest> = new Map();\r\n  private benchmarks: Map<string, PerformanceBenchmark> = new Map();\r\n  private capturedRequests: Map<string, { request: ApiRequest; response?: ApiResponse }> = new Map();\r\n\r\n  constructor() {\r\n    this.loadFromStorage();\r\n  }\r\n\r\n  /**\r\n   * Load data from Chrome storage\r\n   */\r\n  private async loadFromStorage(): Promise<void> {\r\n    try {\r\n      const result = await chrome.storage.local.get([\r\n        'api_test_cases',\r\n        'api_mocks',\r\n        'api_contracts',\r\n        'api_benchmarks'\r\n      ]);\r\n\r\n      if (result.api_test_cases) {\r\n        this.testCases = new Map(Object.entries(result.api_test_cases));\r\n      }\r\n      if (result.api_mocks) {\r\n        this.mocks = new Map(Object.entries(result.api_mocks));\r\n      }\r\n      if (result.api_contracts) {\r\n        this.contracts = new Map(Object.entries(result.api_contracts));\r\n      }\r\n      if (result.api_benchmarks) {\r\n        this.benchmarks = new Map(Object.entries(result.api_benchmarks));\r\n      }\r\n    } catch (error) {\r\n      console.error('Error loading API testing data:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Save data to Chrome storage\r\n   */\r\n  private async saveToStorage(): Promise<void> {\r\n    try {\r\n      await chrome.storage.local.set({\r\n        api_test_cases: Object.fromEntries(this.testCases),\r\n        api_mocks: Object.fromEntries(this.mocks),\r\n        api_contracts: Object.fromEntries(this.contracts),\r\n        api_benchmarks: Object.fromEntries(this.benchmarks)\r\n      });\r\n    } catch (error) {\r\n      console.error('Error saving API testing data:', error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Capture network request from Playwright\r\n   */\r\n  captureRequest(request: ApiRequest): void {\r\n    this.capturedRequests.set(request.id, { request });\r\n  }\r\n\r\n  /**\r\n   * Capture network response from Playwright\r\n   */\r\n  captureResponse(response: ApiResponse): void {\r\n    const captured = this.capturedRequests.get(response.requestId);\r\n    if (captured) {\r\n      captured.response = response;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get all captured requests\r\n   */\r\n  getCapturedRequests(): Array<{ request: ApiRequest; response?: ApiResponse }> {\r\n    return Array.from(this.capturedRequests.values());\r\n  }\r\n\r\n  /**\r\n   * Clear captured requests\r\n   */\r\n  clearCapturedRequests(): void {\r\n    this.capturedRequests.clear();\r\n  }\r\n\r\n  /**\r\n   * Create test case from captured request\r\n   */\r\n  createTestCaseFromRequest(requestId: string, name: string): ApiTestCase | null {\r\n    const captured = this.capturedRequests.get(requestId);\r\n    if (!captured) return null;\r\n\r\n    const testCase: ApiTestCase = {\r\n      id: `test-${Date.now()}`,\r\n      name,\r\n      request: captured.request,\r\n      assertions: [],\r\n      response: captured.response,\r\n      createdAt: new Date(),\r\n      updatedAt: new Date()\r\n    };\r\n\r\n    // Auto-generate basic assertions if response exists\r\n    if (captured.response) {\r\n      testCase.assertions.push({\r\n        id: `assert-${Date.now()}-1`,\r\n        type: 'status',\r\n        operator: 'equals',\r\n        expected: captured.response.status,\r\n        actual: captured.response.status,\r\n        passed: true,\r\n        message: `Status code should be ${captured.response.status}`\r\n      });\r\n\r\n      testCase.assertions.push({\r\n        id: `assert-${Date.now()}-2`,\r\n        type: 'response-time',\r\n        operator: 'less-than',\r\n        expected: 2000,\r\n        actual: captured.response.responseTime,\r\n        passed: captured.response.responseTime < 2000,\r\n        message: 'Response time should be less than 2000ms'\r\n      });\r\n    }\r\n\r\n    this.testCases.set(testCase.id, testCase);\r\n    this.saveToStorage();\r\n    return testCase;\r\n  }\r\n\r\n  /**\r\n   * Add test case\r\n   */\r\n  addTestCase(testCase: ApiTestCase): void {\r\n    this.testCases.set(testCase.id, testCase);\r\n    this.saveToStorage();\r\n  }\r\n\r\n  /**\r\n   * Update test case\r\n   */\r\n  updateTestCase(id: string, updates: Partial<ApiTestCase>): void {\r\n    const testCase = this.testCases.get(id);\r\n    if (testCase) {\r\n      Object.assign(testCase, updates, { updatedAt: new Date() });\r\n      this.saveToStorage();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete test case\r\n   */\r\n  deleteTestCase(id: string): void {\r\n    this.testCases.delete(id);\r\n    this.saveToStorage();\r\n  }\r\n\r\n  /**\r\n   * Get all test cases\r\n   */\r\n  getTestCases(): ApiTestCase[] {\r\n    return Array.from(this.testCases.values());\r\n  }\r\n\r\n  /**\r\n   * Execute test case\r\n   */\r\n  async executeTestCase(id: string): Promise<ApiTestCase> {\r\n    const testCase = this.testCases.get(id);\r\n    if (!testCase) throw new Error('Test case not found');\r\n\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      // Execute request\r\n      const response = await fetch(testCase.request.url, {\r\n        method: testCase.request.method,\r\n        headers: testCase.request.headers,\r\n        body: testCase.request.body\r\n      });\r\n\r\n      const responseTime = Date.now() - startTime;\r\n      const responseBody = await response.text();\r\n\r\n      const apiResponse: ApiResponse = {\r\n        id: `resp-${Date.now()}`,\r\n        requestId: testCase.request.id,\r\n        status: response.status,\r\n        statusText: response.statusText,\r\n        headers: Object.fromEntries(response.headers.entries()),\r\n        body: responseBody,\r\n        responseTime,\r\n        timestamp: Date.now()\r\n      };\r\n\r\n      testCase.response = apiResponse;\r\n\r\n      // Execute assertions\r\n      for (const assertion of testCase.assertions) {\r\n        await this.executeAssertion(assertion, apiResponse, responseBody);\r\n      }\r\n\r\n      testCase.updatedAt = new Date();\r\n      this.saveToStorage();\r\n\r\n      return testCase;\r\n    } catch (error) {\r\n      throw new Error(`Test execution failed: ${error}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Execute assertion\r\n   */\r\n  private async executeAssertion(assertion: ApiAssertion, response: ApiResponse, responseBody: string): Promise<void> {\r\n    let actual: any;\r\n    let passed = false;\r\n\r\n    switch (assertion.type) {\r\n      case 'status':\r\n        actual = response.status;\r\n        passed = this.compare(actual, assertion.expected, assertion.operator);\r\n        break;\r\n\r\n      case 'header':\r\n        actual = response.headers[assertion.path || ''];\r\n        passed = this.compare(actual, assertion.expected, assertion.operator);\r\n        break;\r\n\r\n      case 'body':\r\n        actual = responseBody;\r\n        passed = this.compare(actual, assertion.expected, assertion.operator);\r\n        break;\r\n\r\n      case 'json-path':\r\n        try {\r\n          const json = JSON.parse(responseBody);\r\n          actual = this.getJsonPath(json, assertion.path || '');\r\n          passed = this.compare(actual, assertion.expected, assertion.operator);\r\n        } catch (error) {\r\n          passed = false;\r\n          assertion.message = `JSON parse error: ${error}`;\r\n        }\r\n        break;\r\n\r\n      case 'json-schema':\r\n        try {\r\n          const json = JSON.parse(responseBody);\r\n          passed = await this.validateJsonSchema(json, assertion.expected);\r\n        } catch (error) {\r\n          passed = false;\r\n          assertion.message = `Schema validation error: ${error}`;\r\n        }\r\n        break;\r\n\r\n      case 'response-time':\r\n        actual = response.responseTime;\r\n        passed = this.compare(actual, assertion.expected, assertion.operator);\r\n        break;\r\n    }\r\n\r\n    assertion.actual = actual;\r\n    assertion.passed = passed;\r\n  }\r\n\r\n  /**\r\n   * Compare values based on operator\r\n   */\r\n  private compare(actual: any, expected: any, operator: string): boolean {\r\n    switch (operator) {\r\n      case 'equals':\r\n        return actual === expected;\r\n      case 'contains':\r\n        return String(actual).includes(String(expected));\r\n      case 'matches':\r\n        return new RegExp(expected).test(String(actual));\r\n      case 'less-than':\r\n        return Number(actual) < Number(expected);\r\n      case 'greater-than':\r\n        return Number(actual) > Number(expected);\r\n      case 'exists':\r\n        return actual !== undefined && actual !== null;\r\n      default:\r\n        return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get value from JSON using path\r\n   */\r\n  private getJsonPath(obj: any, path: string): any {\r\n    const keys = path.split('.');\r\n    let current = obj;\r\n    for (const key of keys) {\r\n      if (current === undefined || current === null) return undefined;\r\n      current = current[key];\r\n    }\r\n    return current;\r\n  }\r\n\r\n  /**\r\n   * Validate JSON against schema (basic implementation)\r\n   */\r\n  private async validateJsonSchema(data: any, schema: any): Promise<boolean> {\r\n    // This is a simplified implementation\r\n    // In production, use a library like ajv\r\n    try {\r\n      if (typeof schema === 'string') {\r\n        schema = JSON.parse(schema);\r\n      }\r\n      // Basic type checking\r\n      if (schema.type && typeof data !== schema.type) {\r\n        return false;\r\n      }\r\n      return true;\r\n    } catch {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add API mock\r\n   */\r\n  addMock(mock: ApiMock): void {\r\n    this.mocks.set(mock.id, mock);\r\n    this.saveToStorage();\r\n  }\r\n\r\n  /**\r\n   * Update mock\r\n   */\r\n  updateMock(id: string, updates: Partial<ApiMock>): void {\r\n    const mock = this.mocks.get(id);\r\n    if (mock) {\r\n      Object.assign(mock, updates);\r\n      this.saveToStorage();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Delete mock\r\n   */\r\n  deleteMock(id: string): void {\r\n    this.mocks.delete(id);\r\n    this.saveToStorage();\r\n  }\r\n\r\n  /**\r\n   * Get all mocks\r\n   */\r\n  getMocks(): ApiMock[] {\r\n    return Array.from(this.mocks.values());\r\n  }\r\n\r\n  /**\r\n   * Get enabled mocks\r\n   */\r\n  getEnabledMocks(): ApiMock[] {\r\n    return Array.from(this.mocks.values()).filter(m => m.enabled);\r\n  }\r\n\r\n  /**\r\n   * Add contract test\r\n   */\r\n  addContract(contract: ContractTest): void {\r\n    this.contracts.set(contract.id, contract);\r\n    this.saveToStorage();\r\n  }\r\n\r\n  /**\r\n   * Get all contracts\r\n   */\r\n  getContracts(): ContractTest[] {\r\n    return Array.from(this.contracts.values());\r\n  }\r\n\r\n  /**\r\n   * Add benchmark\r\n   */\r\n  addBenchmark(benchmark: PerformanceBenchmark): void {\r\n    this.benchmarks.set(benchmark.id, benchmark);\r\n    this.saveToStorage();\r\n  }\r\n\r\n  /**\r\n   * Run benchmark\r\n   */\r\n  async runBenchmark(id: string, iterations: number = 10): Promise<PerformanceBenchmark> {\r\n    const benchmark = this.benchmarks.get(id);\r\n    if (!benchmark) throw new Error('Benchmark not found');\r\n\r\n    benchmark.measurements = [];\r\n\r\n    for (let i = 0; i < iterations; i++) {\r\n      const startTime = Date.now();\r\n      try {\r\n        const response = await fetch(benchmark.endpoint, {\r\n          method: benchmark.method\r\n        });\r\n        const responseTime = Date.now() - startTime;\r\n        benchmark.measurements.push({\r\n          timestamp: new Date(),\r\n          responseTime,\r\n          success: response.ok\r\n        });\r\n      } catch (error) {\r\n        benchmark.measurements.push({\r\n          timestamp: new Date(),\r\n          responseTime: Date.now() - startTime,\r\n          success: false\r\n        });\r\n      }\r\n    }\r\n\r\n    // Calculate statistics\r\n    const times = benchmark.measurements.map(m => m.responseTime).sort((a, b) => a - b);\r\n    benchmark.avgResponseTime = times.reduce((a, b) => a + b, 0) / times.length;\r\n    benchmark.minResponseTime = Math.min(...times);\r\n    benchmark.maxResponseTime = Math.max(...times);\r\n    benchmark.p50 = times[Math.floor(times.length * 0.5)];\r\n    benchmark.p95 = times[Math.floor(times.length * 0.95)];\r\n    benchmark.p99 = times[Math.floor(times.length * 0.99)];\r\n\r\n    this.saveToStorage();\r\n    return benchmark;\r\n  }\r\n\r\n  /**\r\n   * Get all benchmarks\r\n   */\r\n  getBenchmarks(): PerformanceBenchmark[] {\r\n    return Array.from(this.benchmarks.values());\r\n  }\r\n\r\n  /**\r\n   * Generate code for API test\r\n   */\r\n  generateCode(testCase: ApiTestCase, language: string): string {\r\n    switch (language) {\r\n      case 'javascript':\r\n      case 'playwright-test':\r\n        return this.generatePlaywrightCode(testCase);\r\n      case 'python':\r\n      case 'python-pytest':\r\n        return this.generatePythonCode(testCase);\r\n      case 'java':\r\n      case 'java-junit':\r\n        return this.generateJavaCode(testCase);\r\n      default:\r\n        return this.generatePlaywrightCode(testCase);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate Playwright test code\r\n   */\r\n  private generatePlaywrightCode(testCase: ApiTestCase): string {\r\n    let code = `import { test, expect } from '@playwright/test';\\n\\n`;\r\n    code += `test('${testCase.name}', async ({ request }) => {\\n`;\r\n    code += `  const response = await request.${testCase.request.method.toLowerCase()}('${testCase.request.url}'`;\r\n\r\n    if (testCase.request.body || Object.keys(testCase.request.headers).length > 0) {\r\n      code += `, {\\n`;\r\n      if (Object.keys(testCase.request.headers).length > 0) {\r\n        code += `    headers: ${JSON.stringify(testCase.request.headers, null, 2)},\\n`;\r\n      }\r\n      if (testCase.request.body) {\r\n        code += `    data: ${testCase.request.body},\\n`;\r\n      }\r\n      code += `  }`;\r\n    }\r\n\r\n    code += `);\\n\\n`;\r\n\r\n    // Add assertions\r\n    for (const assertion of testCase.assertions) {\r\n      switch (assertion.type) {\r\n        case 'status':\r\n          code += `  expect(response.status()).toBe(${assertion.expected});\\n`;\r\n          break;\r\n        case 'header':\r\n          code += `  expect(response.headers()['${assertion.path}']).toBe('${assertion.expected}');\\n`;\r\n          break;\r\n        case 'json-path':\r\n          code += `  const body = await response.json();\\n`;\r\n          code += `  expect(body.${assertion.path}).toBe(${JSON.stringify(assertion.expected)});\\n`;\r\n          break;\r\n        case 'response-time':\r\n          code += `  // Response time assertion - implement with custom logic\\n`;\r\n          break;\r\n      }\r\n    }\r\n\r\n    code += `});\\n`;\r\n    return code;\r\n  }\r\n\r\n  /**\r\n   * Generate Python test code\r\n   */\r\n  private generatePythonCode(testCase: ApiTestCase): string {\r\n    let code = `import pytest\\nfrom playwright.sync_api import sync_playwright\\n\\n`;\r\n    code += `def test_${testCase.name.toLowerCase().replace(/\\s+/g, '_')}():\\n`;\r\n    code += `    with sync_playwright() as p:\\n`;\r\n    code += `        browser = p.chromium.launch()\\n`;\r\n    code += `        context = browser.new_context()\\n`;\r\n    code += `        page = context.new_page()\\n\\n`;\r\n    code += `        response = context.request.${testCase.request.method.toLowerCase()}(\"${testCase.request.url}\")\\n\\n`;\r\n\r\n    for (const assertion of testCase.assertions) {\r\n      if (assertion.type === 'status') {\r\n        code += `        assert response.status == ${assertion.expected}\\n`;\r\n      }\r\n    }\r\n\r\n    code += `        browser.close()\\n`;\r\n    return code;\r\n  }\r\n\r\n  /**\r\n   * Generate Java test code\r\n   */\r\n  private generateJavaCode(testCase: ApiTestCase): string {\r\n    let code = `import com.microsoft.playwright.*;\\nimport org.junit.jupiter.api.*;\\n\\n`;\r\n    code += `class ApiTest {\\n`;\r\n    code += `    @Test\\n`;\r\n    code += `    void ${testCase.name.replace(/\\s+/g, '')}() {\\n`;\r\n    code += `        try (Playwright playwright = Playwright.create()) {\\n`;\r\n    code += `            APIRequestContext request = playwright.request().newContext();\\n`;\r\n    code += `            APIResponse response = request.${testCase.request.method.toLowerCase()}(\"${testCase.request.url}\");\\n\\n`;\r\n\r\n    for (const assertion of testCase.assertions) {\r\n      if (assertion.type === 'status') {\r\n        code += `            assertEquals(${assertion.expected}, response.status());\\n`;\r\n      }\r\n    }\r\n\r\n    code += `        }\\n`;\r\n    code += `    }\\n`;\r\n    code += `}\\n`;\r\n    return code;\r\n  }\r\n}\r\n\r\n// Export singleton instance\r\nexport const apiTestingService = new ApiTestingService();\r\n"],"names":["_a","error"],"mappings":"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"}